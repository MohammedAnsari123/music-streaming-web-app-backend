-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- 1. SONGS TABLE (Music)
create table if not exists songs (
  id bigint primary key generated always as identity,
  title text not null,
  artist text not null,
  album text,
  category text, 
  song_url text not null,
  image_url text, 
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 2. PODCASTS TABLE
create table if not exists podcasts (
  id uuid default uuid_generate_v4() primary key,
  title text not null,
  publisher text,
  description text,
  image_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 3. EPISODES TABLE
create table if not exists episodes (
  id uuid default uuid_generate_v4() primary key,
  podcast_id uuid references podcasts(id) on delete cascade not null,
  title text not null,
  description text,
  duration text, 
  audio_url text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 4. PLAYLISTS TABLE
create table if not exists playlists (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references auth.users not null, 
  name text not null,
  description text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 5. PLAYLIST_TRACKS TABLE (Updated with External Support)
create table if not exists playlist_tracks (
  id uuid default uuid_generate_v4() primary key,
  playlist_id uuid references playlists(id) on delete cascade not null,
  track_id text not null, -- Changed from bigint to text to support external IDs
  source text default 'local', -- 'local', 'spotify', 'audius'
  external_data jsonb, -- Snapshot of metadata for external tracks
  added_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(playlist_id, track_id) 
);

-- 6. RECENTLY PLAYED TABLE
create table if not exists recently_played (
  history_id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade,
  track_id bigint references songs(id) on delete cascade,
  episode_id uuid references episodes(id) on delete cascade,
  content_type text check (content_type in ('music', 'podcast')),
  last_position numeric default 0,
  played_at timestamp with time zone default now(),
  constraint check_content_reference check (
    (content_type = 'music' and track_id is not null) or
    (content_type = 'podcast' and episode_id is not null)
  ),
  unique(user_id, track_id),
  unique(user_id, episode_id)
);

-- 7. FAVORITES TABLE (Liked Songs)
create table if not exists favorites (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references auth.users not null,
  song_id text not null,
  source text default 'local',
  external_data jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, song_id)
);


-- ==========================================
-- ROW LEVEL SECURITY (RLS) & POLICIES
-- ==========================================

-- SONGS
alter table songs enable row level security;
create policy "Public songs access" on songs for select using (true);
create policy "Admin insert songs" on songs for insert to authenticated with check (true); 
-- Note: 'true' allows any auth user (we limit via middleware in backend, but ideally use role check here)

-- PODCASTS
alter table podcasts enable row level security;
create policy "Public podcasts access" on podcasts for select using (true);
create policy "Admin insert podcasts" on podcasts for insert to authenticated with check (true);

-- EPISODES
alter table episodes enable row level security;
create policy "Public episodes access" on episodes for select using (true);
create policy "Admin insert episodes" on episodes for insert to authenticated with check (true);

-- PLAYLISTS
alter table playlists enable row level security;
create policy "Users view own playlists" on playlists for select using (auth.uid() = user_id);
create policy "Users insert own playlists" on playlists for insert with check (auth.uid() = user_id);
create policy "Users delete own playlists" on playlists for delete using (auth.uid() = user_id);

-- PLAYLIST TRACKS
alter table playlist_tracks enable row level security;
-- Allow actions if the user owns the parent playlist
create policy "Users view playlist tracks" on playlist_tracks for select using (
  exists (select 1 from playlists where playlists.id = playlist_tracks.playlist_id and playlists.user_id = auth.uid())
);
create policy "Users add playlist tracks" on playlist_tracks for insert with check (
  exists (select 1 from playlists where playlists.id = playlist_tracks.playlist_id and playlists.user_id = auth.uid())
);
create policy "Users remove playlist tracks" on playlist_tracks for delete using (
  exists (select 1 from playlists where playlists.id = playlist_tracks.playlist_id and playlists.user_id = auth.uid())
);

-- RECENTLY PLAYED
alter table recently_played enable row level security;
create policy "Users view own history" on recently_played for select using (auth.uid() = user_id);
create policy "Users insert own history" on recently_played for insert with check (auth.uid() = user_id);
create policy "Users update own history" on recently_played for update using (auth.uid() = user_id);

-- FAVORITES
alter table favorites enable row level security;
create policy "Users view own favorites" on favorites for select using (auth.uid() = user_id);
create policy "Users insert own favorites" on favorites for insert with check (auth.uid() = user_id);
create policy "Users delete own favorites" on favorites for delete using (auth.uid() = user_id);

-- STORAGE BUCKETS (If running manually in SQL Editor)
-- insert into storage.buckets (id, name, public) values ('songs', 'songs', true) on conflict do nothing;
-- insert into storage.buckets (id, name, public) values ('images', 'images', true) on conflict do nothing;
-- insert into storage.buckets (id, name, public) values ('podcasts', 'podcasts', true) on conflict do nothing;

-- STORAGE POLICIES (Example)
-- create policy "Public Access Songs" on storage.objects for select using ( bucket_id = 'songs' );
-- create policy "Admin Upload Songs" on storage.objects for insert with check ( bucket_id = 'songs' );
